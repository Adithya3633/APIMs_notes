<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Data JPA Guide</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            color: #333;
        }

        header {
            background-color: #1976d2;
            color: white;
            padding: 1rem 2rem;
            text-align: center;
        }

        main {
            max-width: 1000px;
            margin: 2rem auto;
            padding: 1rem 2rem;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1, h2, h3, h4 {
            color: #1976d2;
        }

        h2 {
            margin-top: 2rem;
            border-bottom: 2px solid #1976d2;
            padding-bottom: 0.2rem;
        }

        h3 {
            margin-top: 1.5rem;
        }

        p {
            margin: 0.5rem 0;
        }

        b {
            font-weight: bold;
        }

        code, pre {
            font-family: 'Courier New', Courier, monospace;
            background: #272822;
            color: #f8f8f2;
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
        }

        pre {
            overflow-x: auto;
            padding: 1rem;
        }

        .section {
            margin-bottom: 2rem;
        }

        ul {
            margin-left: 1.5rem;
        }

        @media (max-width: 768px) {
            main {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>

<header>
    <h1>Spring Data JPA Complete Guide</h1>
    <p>All concepts, examples, and best practices</p>
</header>

<main>
    <section class="section">
        <h2>Why Spring Data JPA</h2>
        <p><b>Spring Data JPA</b> is a part of the Spring Data project that provides a higher-level abstraction over JPA and JDBC. It addresses the limitations of plain JDBC:</p>
        
        <h3>1. Remove Boilerplate Code</h3>
        <p>No need to write JDBC code. Developers define interfaces for CRUD operations instead of writing implementations.</p>
        <pre><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    // no need to implement methods manually
}</code></pre>
        
        <h3>2. Built-in ORM</h3>
        <p>Maps Java entities to database tables automatically. Reduces normal mapping effort and errors.</p>
        
        <h3>3. Derived Query Methods</h3>
        <p>Supports query generation from method names.</p>
        <pre><code>List&lt;User&gt; findByLastName(String lastName);</code></pre>
        
        <h3>4. Automatic Query Generation</h3>
        <p>Spring Data JPA generates JPQL or SQL queries automatically based on method names.</p>
        
        <h3>5. Integration with Spring Boot</h3>
        <p>Auto-configuration detects repositories and sets up EntityManager. Transactions are managed easily.</p>
    </section>

    <section class="section">
        <h2>Limitations of JDBC API</h2>
        <ul>
            <li><b>Boilerplate Code:</b> Requires manual handling of connections, statements, exceptions, and transactions.</li>
            <li><b>Complex Mapping:</b> Mapping SQL result sets to Java objects is error-prone.</li>
            <li><b>Manual Query Construction & Security Risks:</b> Prone to SQL injection.</li>
            <li><b>No ORM:</b> JDBC does not map objects automatically.</li>
            <li><b>Complex Transaction Management:</b> Developers must manually begin, commit, or rollback transactions.</li>
        </ul>
    </section>

    <section class="section">
        <h2>Spring Boot Auto-Configuration in Spring Data JPA</h2>
        <ul>
            <li><b>Automatic EntityManager Support:</b> Auto-configures EntityManagerFactory and EntityManager.</li>
            <li><b>Automatic DataSource Configuration:</b> Configured using application.properties/yml.</li>
            <pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/testdb
spring.datasource.username=root
spring.datasource.password=pass</code></pre>
            <li><b>Default JPA Repository Support:</b> Spring Boot detects repositories extending JpaRepository.</li>
            <li><b>Transaction Management:</b> PlatformTransactionManager is auto-configured, supporting @Transactional.</li>
            <li><b>Sensible JPA/Hibernate Defaults:</b> e.g., <code>spring.jpa.hibernate.ddl-auto=update</code></li>
        </ul>

        <h3>Example Spring Boot Application</h3>
        <pre><code>@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}</code></pre>
    </section>

    <section class="section">
        <h2>Transactions and Spring Transaction Management</h2>
        <p>Transactions ensure <b>consistency, integrity, and reliability</b> of data.</p>

        <h3>Importance of Transactions</h3>
        <ul>
            <li><b>Atomicity:</b> All operations succeed or fail together.</li>
            <li><b>Consistency:</b> Database constraints are maintained.</li>
            <li><b>Isolation:</b> Prevents interference between concurrent operations.</li>
            <li><b>Durability:</b> Committed changes persist even after crashes.</li>
        </ul>

        <h3>Benefits with Spring</h3>
        <ul>
            <li>Declarative transactions with @Transactional.</li>
            <li>Automatic commit/rollback on success or exception.</li>
            <li>Read-only optimization: <code>@Transactional(readOnly = true)</code></li>
        </ul>

        <h3>Example: Handling Runtime Exceptions</h3>
        <pre><code>@Entity
public class Student {
    @Id
    private int id;
    private String name;
    private int marks;
    // getters and setters
}

@Service
public class StudentService {
    @Autowired
    private StudentRepository repo;

    @Transactional
    public void updateMarks(int id, int marks) {
        Student s = repo.findById(id).orElseThrow();
        s.setMarks(marks);
        repo.save(s);
        if (marks &lt; 0) {
            throw new RuntimeException("Invalid marks");
        }
    }
}</code></pre>
    </section>

    <section class="section">
        <h2>Custom Repository Implementation</h2>
        <pre><code>public interface A {
    void function();
}

public class B implements A {
    private EntityManager em;

    @Override
    public void function() {
        // logic using EntityManager
    }
}

public interface ARepository extends JpaRepository&lt;Entity, ID&gt;, A {
    // can use both built-in and custom methods
}</code></pre>
    </section>

    <section class="section">
        <h2>Optimizing Queries</h2>
        <ul>
            <li>Prefer JPQL or repository methods over native SQL.</li>
            <li>Use pagination for large datasets.</li>
            <li>Avoid N+1 select problem with <code>@EntityGraph</code>.</li>
            <li>Write efficient custom queries with <code>@Query</code>.</li>
            <li>Monitor SQL logs:
                <pre><code>spring.data.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true</code></pre>
            </li>
            <li>Index frequently queried columns.</li>
            <li>Keep transactions short.</li>
        </ul>
    </section>

    <section class="section">
        <h2>Project Structure & Naming Conventions</h2>
        <pre><code>com.app
├─ entity       // JPA entities
├─ repository   // Spring Data JPA interfaces
├─ service      // Business logic
├─ controller   // REST controllers
└─ config       // JPA & other configurations
</code></pre>

        <p><b>Naming Conventions:</b></p>
        <ul>
            <li>Entities: PascalCase (Student, Order)</li>
            <li>Repositories: Entity + Repository (StudentRepository)</li>
            <li>Services: Entity + Service (StudentService)</li>
            <li>Controllers: Entity + Controller (StudentController)</li>
            <li>Packages: lowercase</li>
            <li>Methods: camelCase</li>
        </ul>
    </section>

    <section class="section">
        <h2>Native SQL Queries</h2>
        <pre><code>@Query(value = "SELECT * FROM student WHERE city = :city", nativeQuery = true)
List&lt;Student&gt; findByCity(@Param("city") String city);

@RestController
public class StudentController {
    @Autowired
    private StudentService service;

    @GetMapping("/city/{c}")
    public List&lt;Student&gt; getCity(@PathVariable("c") String c) {
        return service.getByCity(c);
    }
}</code></pre>
    </section>

    <section class="section">
        <h2>Sorting in Spring Data JPA</h2>
        <pre><code>@RestController
public class StudentController {
    @Autowired
    private StudentRepository repo;

    @GetMapping("/students/sort")
    public List&lt;Student&gt; getSorted() {
        return repo.findAll(Sort.by("marks").descending());
    }
}</code></pre>
    </section>

    <section class="section">
        <h2>JPQL & Named Queries</h2>
        <pre><code>@Entity
@NamedQuery(
    name = "Student.findByCity",
    query = "SELECT s FROM Student s WHERE s.city = :city"
)
public class Student { }</code></pre>

        <h3>Named Native Query</h3>
        <pre><code>@Entity
@NamedNativeQuery(
    name = "Student.query",
    query = "SELECT * FROM student WHERE marks > :m",
    resultClass = Student.class
)
public class Student { }</code></pre>
    </section>

</main>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
</body>
</html>
